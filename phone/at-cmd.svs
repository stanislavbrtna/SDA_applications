# init

function at_init {
  at_success  = 0;
  at_result   = "";
  at_ticket   = 0;
  at_ticket_n = 0;
  at_timeout  = 0;
  at_enabled  = 0;
  at_result   = "";
  at_simcmd   = "";
  at_quiet    = 0;
  at_ring     = 0;
  at_cooldown = 0;
  
  at_ustring  = "";
  
  DEBUG = 1;
  
  simpin = 0;
  
  RES_OK = 1;
  RES_ERR = 2;
}


function at_init_io {
  # RX, TX
  sys.hw.iPinDef(7, PIN_ALT, PIN_NOPULL);
  sys.hw.iPinDef(8, PIN_ALT, PIN_NOPULL);
  
  # Reset
  sys.hw.iPinDef(11, PIN_OUT, PIN_NOPULL);
  sys.hw.iPinSet(11, 1);
  
  # DTR
  sys.hw.iPinDef(10, PIN_OUT, PIN_NOPULL);
  sys.hw.iPinSet(10, 0);
  
  # RNG
  sys.hw.iPinDef(9, PIN_IN, PIN_NOPULL);
  
  # Disable the external uart
  sys.hw.ePinDef(5, PIN_IN, PIN_NOPULL);
  sys.hw.ePinDef(6, PIN_IN, PIN_NOPULL);
  
  # start receive
  sys.com.uartRcvIT();
  
  # clear all buffers
  if (not sys.os.inSim()) {
    sys.com.uartGetRd();
    sys.com.uartGetStr();
  }
}


 # this needs to be fixed
function at_reset_hw {
  sys.hw.iPinSet(11, 0);
  at_wait(1000);
  sys.hw.iPinSet(11, 1);
}

 # val: 1 - enable sleep, 0 - disable sleep 
function at_set_dtr {
  if (arg0) {
    sys.hw.iPinSet(10, 1);
  } else {
    sys.hw.iPinSet(10, 0);
  }
}

function at_get_ri {
  return sys.hw.iPinGet(9);
}

function at_command {
  if (at_ticket != 0) {
    print("AT_WARN: command not yet processed! (" + arg0 + ")");
    
    if (sys.time.getAppUptime() > at_timeout or at_timeout == 0) {
      print("AT_WARN: command was borked (" + at_simcmd + ")");
      at_reset();
    } else {
      return 0;
    }
  }
  
  if (at_cooldown + 500 > sys.time.getAppUptime()) {
    at_wait(500);
  }
  
  at_init_io();
  at_success = 0;
  at_enabled = 1;
  
  at_ticket_n++;
  
  at_ticket = at_ticket_n;
  
  at_ustring = "";
  
  #printing something breaks the comms
  
  at_result = "";
  
  if(sys.os.inSim()) {
    if (DEBUG) print("Simulated AT Command: " + arg0 + " ticket: " + at_ticket);
    at_simcmd = arg0;
  } else {
    at_simcmd = arg0;
    # clean up stuff
    gc(100);
    # send message
    sys.com.uartTrs(arg0 + "\r\n");
    at_wait(50);
  }
  
  if (arg1 == 0) {
    at_timeout = sys.time.getAppUptime() + 3000;
  } else {
    at_timeout = sys.time.getAppUptime() + 100*arg1;
  }
  
  if(DEBUG) print("CMD: " + arg0 + " timeout: " + at_timeout);
  
  return at_ticket;
}

function at_result #* Ticket *# {
  if (at_ticket == arg0 and at_success == 1 and at_ticket != 0) {
    at_reset();
    return 1;
  }
  
  if (at_ticket == arg0 and at_success == 2 and at_ticket != 0) {
    at_reset();
    return 2;
  }
  
  return 0;
}


function at_reset {
  if (DEBUG) print("at_reset called (" + at_simcmd + ")");
  
  at_enabled = 0;
  at_timeout = 0;
  at_ticket  = 0;
  at_success = 0;
  if(not sys.os.inSim()) {
    sys.com.uartGetRd();
    sys.com.uartGetStr();
    sys.com.uartRcvIT();
  }
  at_wait(100);
}


function at_update {

  local x = "";
  local cnt = 0;
  
  if (not sys.os.inSim()) {
    if (sys.com.uartGetRd()) {
      at_ustring += sys.com.uartGetStr();
      #print("got ustring: " + at_ustring);
    }
  } else {
    if (at_ustring == "") {
      if (DEBUG) print("Simulated result for ticket: " + at_ticket + " timeout: " + at_timeout);
      at_ustring = at_simcmd + "\nSIMULATED\nOK\r\n";
      gc(100);
      
      if(at_simcmd == "AT+CPIN?" and simpin) {
        at_ustring = "SIMULATED:\n+CPIN: READY\r\nOK\r\n";
      } else {
        at_ustring = "SIMULATED:\n+CPIN: SIM PIN\r\nOK\r\n";
      }
      
      if(at_simcmd == "AT+CPIN=1234") {
        at_ustring = "SIMULATED:\n+CPIN: OK\r\n";
        simpin = 1;
      }
      
      if(at_simcmd == "AT+CMGR=1") {
        at_ustring = "at+cmgr=1\n\r+CMGR: \"REC READ\",\"00310032003300340035003600370038\",\"\",\"23/12/09,16:50:53+04\r\n0050015900ED006C006901610020017E006C00750165006F0075010D006B00FD0020006B016F01480020006400760061\n\rOK";
      }
      
      if(at_simcmd == "AT+CMGR=11") {
        at_ustring = "at+cmgr=1\n\r+CMGR:\n\rERROR\n\r";
      }
      
      if(at_simcmd == "AT+CLCC") {
        at_ustring = "AT+CLCC: 0 result: AT+CLCC\r\n+CLCC: 1,1,4,0,0,\"+420123456789\",145,\"\"\r\nOK\r\n";
      }
    }
  }
    
  if (at_enabled) {
    at_result = at_ustring;
      
    #if (substr(at_result, len(at_result) - 3, len(at_result) - 2) == "OK") {
    if (instr(at_result, "OK")) {
      at_success = 1;
      at_enabled = 0;
      at_cooldown = sys.time.getAppUptime();
    }
    
    #if (substr(at_result, len(at_result) - 3, len(at_result) - 2) == "OR") {
    if (instr(at_result, "ERROR")) {
      if (not at_quiet) {
        sys.os.error("AT CMD ERROR\nCMD: " + at_simcmd +"\nError: " + at_result);
      } else {
        print("AT CMD ERROR\nCMD: " + at_simcmd +"\nError: " + at_result + " substr: " + substr(at_result, len(at_result) - 3, len(at_result) - 2));
      }
      at_success = 2;
      at_enabled = 0;
      at_cooldown = sys.time.getAppUptime();
    }
    
    if (sys.time.getAppUptime() > at_timeout and at_timeout != 0 and at_success == 0) {
      if (not at_quiet) {
        sys.os.error("AT CMD Timeout\nCMD: " + at_simcmd +"\nError: " + at_result);
      } else {
        print("AT CMD Timeout\nCMD: " + at_simcmd +"\nError: " + at_result);
        if (DEBUG) print(" ok found: " + instr(at_result, "OK") + " error found " + instr(at_result, "ERROR"));
      }
      
      if(DEBUG) print("Resolved: " + at_simcmd + " timeout: " + at_timeout + "time: " + sys.time.getAppUptime());
      
      at_timeout = 0;
      at_success = 2;
      at_enabled = 0;
      at_cooldown = sys.time.getAppUptime();
    }
  }
  
  # get the unsolicited messages
  
  if(instr(at_ustring, "RING")) {
    at_ring = 1;
    at_ustring = "";
  }
}

function at_wait {
  if(not sys.os.inSim()) {
    local time = sys.time.getAppUptime() + arg0;
    
    while(1) {
      if (sys.time.getAppUptime() > time) {
        break;
      }
    }
  }
}


